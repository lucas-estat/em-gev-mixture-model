---
title: "Trabalho_estat_comp"
output:
  pdf_document: 
    latex_engine: xelatex
  html_document: default
date: "2025-07-03"
---

```{r}
# ====================================================================
# ETAPA 1: FUNÃ‡Ã•ES DE BASE DA DISTRIBUIÃ‡ÃƒO GEV
# ====================================================================
library(here)

# FunÃ§Ã£o de densidade da distribuiÃ§Ã£o GEV
dgev <- function(x, gamma, mu, sigma) {
  # ValidaÃ§Ã£o dos parÃ¢metros
  if (sigma <= 0) {
    stop("ParÃ¢metro sigma deve ser positivo")
  }
  
  # Inicializar vetor de resultado
  result <- numeric(length(x))
  
  if (abs(gamma) < 1e-10) {
    # Caso Î³ = 0 (distribuiÃ§Ã£o de Gumbel)
    z <- (x - mu) / sigma
    result <- (1/sigma) * exp(-z) * exp(-exp(-z))
  } else {
    # Caso Î³ â‰  0
    z <- 1 + gamma * (x - mu) / sigma
    
    # Verificar restriÃ§Ã£o de suporte
    valid <- z > 0
    result[!valid] <- 0
    
    if (any(valid)) {
      z_valid <- z[valid]
      result[valid] <- (1/sigma) * (z_valid^(-1/gamma - 1)) * exp(-(z_valid^(-1/gamma)))
    }
  }
  
  return(result)
}

# FunÃ§Ã£o de distribuiÃ§Ã£o acumulada da GEV
pgev <- function(x, gamma, mu, sigma) {
  # ValidaÃ§Ã£o dos parÃ¢metros
  if (sigma <= 0) {
    stop("ParÃ¢metro sigma deve ser positivo")
  }
  
  # Inicializar vetor de resultado
  result <- numeric(length(x))
  
  if (abs(gamma) < 1e-10) {
    # Caso Î³ = 0 (distribuiÃ§Ã£o de Gumbel)
    z <- (x - mu) / sigma
    result <- exp(-exp(-z))
  } else {
    # Caso Î³ â‰  0
    z <- 1 + gamma * (x - mu) / sigma
    
    # Verificar restriÃ§Ã£o de suporte
    if (gamma > 0) {
      # Para Î³ > 0, x pode ser qualquer valor >= mu - sigma/gamma
      valid <- z > 0
      result[!valid] <- 0
      result[valid & z > 0] <- exp(-(z[valid & z > 0]^(-1/gamma)))
    } else {
      # Para Î³ < 0, x deve ser <= mu - sigma/gamma
      upper_bound <- mu - sigma/gamma
      result[x > upper_bound] <- 1
      valid <- x <= upper_bound
      if (any(valid)) {
        z_valid <- z[valid]
        result[valid] <- exp(-(z_valid^(-1/gamma)))
      }
    }
  }
  
  return(result)
}

# FunÃ§Ã£o quantil da distribuiÃ§Ã£o GEV (inversa da pgev)
qgev <- function(p, gamma, mu, sigma) {
  # ValidaÃ§Ã£o dos parÃ¢metros
  if (sigma <= 0) {
    stop("ParÃ¢metro sigma deve ser positivo")
  }
  if (any(p < 0 | p > 1)) {
    stop("Probabilidades devem estar entre 0 e 1")
  }
  
  # Inicializar vetor de resultado
  result <- numeric(length(p))
  
  if (abs(gamma) < 1e-10) {
    # Caso Î³ = 0 (distribuiÃ§Ã£o de Gumbel)
    result <- mu - sigma * log(-log(p))
  } else {
    # Caso Î³ â‰  0
    # Da equaÃ§Ã£o: p = exp(-(1 + Î³(x-Î¼)/Ïƒ)^(-1/Î³))
    # Resolvendo para x: x = Î¼ + (Ïƒ/Î³)((âˆ’log(p))^(-Î³) âˆ’ 1)
    result <- mu + (sigma/gamma) * ((-log(p))^(-gamma) - 1)
  }
  
  return(result)
}

# FunÃ§Ã£o para testar as implementaÃ§Ãµes
test_gev_functions <- function() {
  cat("=== TESTANDO FUNÃ‡Ã•ES GEV ===\n")
  
  # ParÃ¢metros de teste
  x_test <- seq(-2, 5, 0.5)
  gamma_test <- c(0, 0.2, -0.3)
  mu_test <- 1
  sigma_test <- 1
  
  for (gamma in gamma_test) {
    cat(sprintf("Gamma = %.1f:\n", gamma))
    
    # Testar densidade
    dens <- dgev(x_test, gamma, mu_test, sigma_test)
    cat(sprintf("  Densidade em x=1: %.4f\n", dgev(1, gamma, mu_test, sigma_test)))
    
    # Testar CDF
    cdf <- pgev(x_test, gamma, mu_test, sigma_test)
    cat(sprintf("  CDF em x=1: %.4f\n", pgev(1, gamma, mu_test, sigma_test)))
    
    # Testar quantil (deve retornar x=1 quando p=CDF(1))
    p_test <- pgev(1, gamma, mu_test, sigma_test)
    q_test <- qgev(p_test, gamma, mu_test, sigma_test)
    cat(sprintf("  Teste quantil: qgev(pgev(1)) = %.4f (esperado: 1.0)\n", q_test))
    cat("\n")
  }
  
  # Verificar se integral da densidade Ã© aproximadamente 1
  for (gamma in gamma_test) {
    if (abs(gamma) < 1e-10) {
      x_grid <- seq(-10, 10, 0.01)
    } else if (gamma > 0) {
      x_grid <- seq(mu_test - sigma_test/gamma + 0.1, 20, 0.01)
    } else {
      x_grid <- seq(-20, mu_test - sigma_test/gamma - 0.1, 0.01)
    }
    
    integral <- sum(dgev(x_grid, gamma, mu_test, sigma_test)) * 0.01
    cat(sprintf("Integral da densidade (gamma=%.1f): %.4f\n", gamma, integral))
  }
}

# Executar teste
test_gev_functions()
```
```{r}
# ====================================================================
# ETAPA 2: GERADOR DE DADOS DA MISTURA GEV
# ====================================================================


# FunÃ§Ã£o para gerar amostras de uma mistura de duas componentes GEV
rgev_mixture <- function(n, p1, gamma1, mu1, sigma1, gamma2, mu2, sigma2) {
  # ValidaÃ§Ã£o dos parÃ¢metros
  if (p1 < 0 || p1 > 1) {
    stop("p1 deve estar entre 0 e 1")
  }
  if (sigma1 <= 0 || sigma2 <= 0) {
    stop("ParÃ¢metros sigma devem ser positivos")
  }
  if (n <= 0) {
    stop("n deve ser positivo")
  }
  
  # Inicializar vetor de resultado
  x <- numeric(n)
  
  # Gerar variÃ¡veis uniformes
  u1 <- runif(n)  # Para escolher qual componente
  u2 <- runif(n)  # Para gerar valores da componente escolhida
  
  # Identificar observaÃ§Ãµes da primeira componente
  component1 <- u1 < p1
  
  # Gerar valores da primeira componente
  if (any(component1)) {
    x[component1] <- qgev(u2[component1], gamma1, mu1, sigma1)
  }
  
  # Gerar valores da segunda componente
  if (any(!component1)) {
    x[!component1] <- qgev(u2[!component1], gamma2, mu2, sigma2)
  }
  
  return(x)
}

# FunÃ§Ã£o para calcular a densidade da mistura
dmixture_gev <- function(x, p1, gamma1, mu1, sigma1, gamma2, mu2, sigma2) {
  dens1 <- dgev(x, gamma1, mu1, sigma1)
  dens2 <- dgev(x, gamma2, mu2, sigma2)
  return(p1 * dens1 + (1 - p1) * dens2)
}

# FunÃ§Ã£o para testar o gerador de dados da mistura
test_mixture_generator <- function() {
  cat("=== TESTANDO GERADOR DE MISTURA GEV ===\n")
  
  # ParÃ¢metros de teste
  n_test <- 1000
  p1_test <- 0.3
  gamma1_test <- 0.5
  mu1_test <- 0
  sigma1_test <- 1
  gamma2_test <- -0.3
  mu2_test <- 3
  sigma2_test <- 1.5
  
  # Gerar amostra
  set.seed(123)
  sample_data <- rgev_mixture(n_test, p1_test, gamma1_test, mu1_test, sigma1_test,
                             gamma2_test, mu2_test, sigma2_test)
  
  cat(sprintf("Amostra gerada com n = %d\n", n_test))
  cat(sprintf("EstatÃ­sticas descritivas:\n"))
  cat(sprintf("  MÃ©dia: %.4f\n", mean(sample_data)))
  cat(sprintf("  Mediana: %.4f\n", median(sample_data)))
  cat(sprintf("  Desvio padrÃ£o: %.4f\n", sd(sample_data)))
  cat(sprintf("  MÃ­nimo: %.4f\n", min(sample_data)))
  cat(sprintf("  MÃ¡ximo: %.4f\n", max(sample_data)))
  
  # Criar grÃ¡fico de densidade
  hist(sample_data, freq = FALSE, breaks = 30, 
       main = "Histograma vs Densidade TeÃ³rica da Mistura",
       xlab = "x", ylab = "Densidade")
  
  # Sobrepor densidade teÃ³rica
  x_grid <- seq(min(sample_data) - 1, max(sample_data) + 1, length.out = 200)
  dens_theoretical <- dmixture_gev(x_grid, p1_test, gamma1_test, mu1_test, sigma1_test,
                                  gamma2_test, mu2_test, sigma2_test)
  lines(x_grid, dens_theoretical, col = "red", lwd = 2)
  
  # Adicionar densidades das componentes individuais
  dens1 <- p1_test * dgev(x_grid, gamma1_test, mu1_test, sigma1_test)
  dens2 <- (1 - p1_test) * dgev(x_grid, gamma2_test, mu2_test, sigma2_test)
  lines(x_grid, dens1, col = "blue", lwd = 1, lty = 2)
  lines(x_grid, dens2, col = "green", lwd = 1, lty = 2)
  
  legend("topright", 
         legend = c("Densidade da Mistura", "Componente 1", "Componente 2"),
         col = c("red", "blue", "green"),
         lwd = c(2, 1, 1),
         lty = c(1, 2, 2))
  
  return(sample_data)
}

# FunÃ§Ã£o para gerar mÃºltiplas amostras (Ãºtil para simulaÃ§Ã£o)
generate_multiple_samples <- function(n_samples, n_obs, p1, gamma1, mu1, sigma1, 
                                    gamma2, mu2, sigma2, seed = NULL) {
  if (!is.null(seed)) {
    set.seed(seed)
  }
  
  samples_list <- list()
  for (i in 1:n_samples) {
    samples_list[[i]] <- rgev_mixture(n_obs, p1, gamma1, mu1, sigma1, 
                                     gamma2, mu2, sigma2)
  }
  
  return(samples_list)
}

# Executar teste
sample_test <- test_mixture_generator()

# Exemplo de uso para cenÃ¡rios especÃ­ficos
cat("\n=== EXEMPLO: GERANDO DADOS PARA CENÃRIOS ESPECÃFICOS ===\n")

# CenÃ¡rio 1: Mistura G+ e G0 (Caso 4 do documento)
scenario1_params <- list(
  p1 = 0.4,
  gamma1 = 1,    # G+
  mu1 = 1,
  sigma1 = 1,
  gamma2 = 0,    # G0 (Gumbel)
  mu2 = 0,
  sigma2 = 2
)

set.seed(456)
scenario1_data <- rgev_mixture(500, scenario1_params$p1, scenario1_params$gamma1,
                              scenario1_params$mu1, scenario1_params$sigma1,
                              scenario1_params$gamma2, scenario1_params$mu2,
                              scenario1_params$sigma2)

cat("CenÃ¡rio 1 (G+ e G0):\n")
cat(sprintf("  MÃ©dia: %.4f, DP: %.4f\n", mean(scenario1_data), sd(scenario1_data)))

# CenÃ¡rio 2: Mistura G- e G0 (Caso 5 do documento)
scenario2_params <- list(
  p1 = 0.5,
  gamma1 = -0.5, # G-
  mu1 = -2,
  sigma1 = 1,
  gamma2 = 0,    # G0 (Gumbel)
  mu2 = 0,
  sigma2 = 1
)

set.seed(789)
scenario2_data <- rgev_mixture(500, scenario2_params$p1, scenario2_params$gamma1,
                              scenario2_params$mu1, scenario2_params$sigma1,
                              scenario2_params$gamma2, scenario2_params$mu2,
                              scenario2_params$sigma2)

cat("CenÃ¡rio 2 (G- e G0):\n")
cat(sprintf("  MÃ©dia: %.4f, DP: %.4f\n", mean(scenario2_data), sd(scenario2_data)))

cat("\nEtapa 2 concluÃ­da com sucesso!\n")
```
```{r}
# ====================================================================
# ETAPA 3: IMPLEMENTAÃ‡ÃƒO DO ALGORITMO EM
# ====================================================================

# Carregar bibliotecas necessÃ¡rias
if (!require(stats)) install.packages("stats")
library(stats)

# FunÃ§Ã£o para calcular log-verossimilhanÃ§a da mistura
log_likelihood_mixture <- function(x, p1, gamma1, mu1, sigma1, gamma2, mu2, sigma2) {
  dens1 <- dgev(x, gamma1, mu1, sigma1)
  dens2 <- dgev(x, gamma2, mu2, sigma2)
  mixture_dens <- p1 * dens1 + (1 - p1) * dens2
  
  # Evitar log(0)
  mixture_dens[mixture_dens <= 0] <- 1e-10
  
  return(sum(log(mixture_dens)))
}

# FunÃ§Ã£o para calcular as probabilidades de pertencimento (Passo E)
calculate_responsibilities <- function(x, p1, gamma1, mu1, sigma1, gamma2, mu2, sigma2) {
  # Calcular densidades das componentes
  dens1 <- dgev(x, gamma1, mu1, sigma1)
  dens2 <- dgev(x, gamma2, mu2, sigma2)
  
  # Calcular numeradores
  num1 <- p1 * dens1
  num2 <- (1 - p1) * dens2
  
  # Calcular denominador (densidade da mistura)
  denom <- num1 + num2
  
  # Evitar divisÃ£o por zero
  denom[denom <= 0] <- 1e-10
  
  # Calcular responsabilidades
  g1 <- num1 / denom
  g2 <- num2 / denom
  
  return(list(g1 = g1, g2 = g2))
}

# FunÃ§Ã£o objetivo para otimizaÃ§Ã£o dos parÃ¢metros GEV (Passo M)
gev_objective <- function(params, x, weights) {
  gamma <- params[1]
  mu <- params[2]
  sigma <- params[3]
  
  if (sigma <= 0) return(1e10)  # Penalizar sigma nÃ£o positivo
  
  # Calcular log-densidades ponderadas
  log_dens <- log(dgev(x, gamma, mu, sigma) + 1e-10)
  
  # Retornar log-verossimilhanÃ§a ponderada negativa (para minimizaÃ§Ã£o)
  return(-sum(weights * log_dens))
}

# FunÃ§Ã£o principal do algoritmo EM
em_gev_mixture <- function(x, initial_params, max_iter = 100, tol = 1e-5, verbose = TRUE) {
  # Extrair parÃ¢metros iniciais
  p1 <- initial_params$p1
  gamma1 <- initial_params$gamma1
  mu1 <- initial_params$mu1
  sigma1 <- initial_params$sigma1
  gamma2 <- initial_params$gamma2
  mu2 <- initial_params$mu2
  sigma2 <- initial_params$sigma2
  
  n <- length(x)
  
  # Armazenar histÃ³rico de log-verossimilhanÃ§a
  log_lik_history <- numeric(max_iter + 1)
  log_lik_history[1] <- log_likelihood_mixture(x, p1, gamma1, mu1, sigma1, gamma2, mu2, sigma2)
  
  if (verbose) {
    cat("=== ALGORITMO EM PARA MISTURA GEV ===\n")
    cat(sprintf("Log-verossimilhanÃ§a inicial: %.6f\n", log_lik_history[1]))
  }
  
  for (iter in 1:max_iter) {
    # =====================================
    # PASSO E: Calcular responsabilidades
    # =====================================
    resp <- calculate_responsibilities(x, p1, gamma1, mu1, sigma1, gamma2, mu2, sigma2)
    g1 <- resp$g1
    g2 <- resp$g2
    
    # =====================================
    # PASSO M: Atualizar parÃ¢metros
    # =====================================
    
    # Atualizar p1 (fÃ³rmula fechada)
    p1_new <- mean(g1)
    
    # Atualizar parÃ¢metros da primeira componente
    try({
      opt1 <- optim(par = c(gamma1, mu1, sigma1),
                    fn = gev_objective,
                    x = x,
                    weights = g1,
                    method = "BFGS",
                    control = list(maxit = 100))
      
      if (opt1$convergence == 0 && opt1$par[3] > 0) {
        gamma1_new <- opt1$par[1]
        mu1_new <- opt1$par[2]
        sigma1_new <- opt1$par[3]
      } else {
        # Manter valores anteriores se otimizaÃ§Ã£o falhar
        gamma1_new <- gamma1
        mu1_new <- mu1
        sigma1_new <- sigma1
      }
    }, silent = TRUE)
    
    # Atualizar parÃ¢metros da segunda componente
    try({
      opt2 <- optim(par = c(gamma2, mu2, sigma2),
                    fn = gev_objective,
                    x = x,
                    weights = g2,
                    method = "BFGS",
                    control = list(maxit = 100))
      
      if (opt2$convergence == 0 && opt2$par[3] > 0) {
        gamma2_new <- opt2$par[1]
        mu2_new <- opt2$par[2]
        sigma2_new <- opt2$par[3]
      } else {
        # Manter valores anteriores se otimizaÃ§Ã£o falhar
        gamma2_new <- gamma2
        mu2_new <- mu2
        sigma2_new <- sigma2
      }
    }, silent = TRUE)
    
    # Calcular nova log-verossimilhanÃ§a
    log_lik_new <- log_likelihood_mixture(x, p1_new, gamma1_new, mu1_new, sigma1_new,
                                         gamma2_new, mu2_new, sigma2_new)
    log_lik_history[iter + 1] <- log_lik_new
    
    # Verificar convergÃªncia
    if (abs(log_lik_new - log_lik_history[iter]) < tol) {
      if (verbose) {
        cat(sprintf("ConvergÃªncia atingida na iteraÃ§Ã£o %d\n", iter))
        cat(sprintf("Log-verossimilhanÃ§a final: %.6f\n", log_lik_new))
      }
      break
    }
    
    # Atualizar parÃ¢metros
    p1 <- p1_new
    gamma1 <- gamma1_new
    mu1 <- mu1_new
    sigma1 <- sigma1_new
    gamma2 <- gamma2_new
    mu2 <- mu2_new
    sigma2 <- sigma2_new
    
    if (verbose && (iter %% 10 == 0 || iter <= 5)) {
      cat(sprintf("IteraÃ§Ã£o %d: Log-lik = %.6f\n", iter, log_lik_new))
    }
  }
  
  # Preparar resultado
  result <- list(
    estimates = list(
      p1 = p1,
      gamma1 = gamma1,
      mu1 = mu1,
      sigma1 = sigma1,
      gamma2 = gamma2,
      mu2 = mu2,
      sigma2 = sigma2
    ),
    log_likelihood = log_lik_new,
    iterations = iter,
    converged = (abs(log_lik_new - log_lik_history[iter]) < tol),
    log_lik_history = log_lik_history[1:(iter + 1)]
  )
  
  return(result)
}

# FunÃ§Ã£o para gerar valores iniciais razoÃ¡veis
generate_initial_params <- function(x, method = "quantiles") {
  if (method == "quantiles") {
    # Usar quantis para estimativas iniciais
    q25 <- quantile(x, 0.25)
    q50 <- quantile(x, 0.50)
    q75 <- quantile(x, 0.75)
    
    initial_params <- list(
      p1 = 0.5,
      gamma1 = 0.2,
      mu1 = q25,
      sigma1 = (q75 - q25) / 2,
      gamma2 = -0.2,
      mu2 = q75,
      sigma2 = (q75 - q25) / 2
    )
  } else if (method == "random") {
    # Valores iniciais aleatÃ³rios
    mean_x <- mean(x)
    sd_x <- sd(x)
    
    initial_params <- list(
      p1 = runif(1, 0.3, 0.7),
      gamma1 = runif(1, -0.5, 0.5),
      mu1 = mean_x + runif(1, -sd_x, sd_x),
      sigma1 = runif(1, sd_x/3, sd_x),
      gamma2 = runif(1, -0.5, 0.5),
      mu2 = mean_x + runif(1, -sd_x, sd_x),
      sigma2 = runif(1, sd_x/3, sd_x)
    )
  }
  
  return(initial_params)
}

# FunÃ§Ã£o de teste do algoritmo EM
test_em_algorithm <- function() {
  cat("=== TESTANDO ALGORITMO EM ===\n")
  
  # ParÃ¢metros verdadeiros
  true_params <- list(
    p1 = 0.4,
    gamma1 = 0.5,
    mu1 = 1,
    sigma1 = 1,
    gamma2 = -0.3,
    mu2 = 3,
    sigma2 = 1.5
  )
  
  # Gerar dados de teste
  set.seed(42)
  n_test <- 200
  test_data <- rgev_mixture(n_test, true_params$p1, true_params$gamma1, 
                           true_params$mu1, true_params$sigma1,
                           true_params$gamma2, true_params$mu2, true_params$sigma2)
  
  # Gerar parÃ¢metros iniciais
  initial_params <- generate_initial_params(test_data, method = "quantiles")
  
  cat("ParÃ¢metros verdadeiros:\n")
  cat(sprintf("  p1=%.3f, gamma1=%.3f, mu1=%.3f, sigma1=%.3f\n", 
              true_params$p1, true_params$gamma1, true_params$mu1, true_params$sigma1))
  cat(sprintf("  gamma2=%.3f, mu2=%.3f, sigma2=%.3f\n", 
              true_params$gamma2, true_params$mu2, true_params$sigma2))
  
  cat("\nParÃ¢metros iniciais:\n")
  cat(sprintf("  p1=%.3f, gamma1=%.3f, mu1=%.3f, sigma1=%.3f\n", 
              initial_params$p1, initial_params$gamma1, initial_params$mu1, initial_params$sigma1))
  cat(sprintf("  gamma2=%.3f, mu2=%.3f, sigma2=%.3f\n", 
              initial_params$gamma2, initial_params$mu2, initial_params$sigma2))
  
  # Executar EM
  em_result <- em_gev_mixture(test_data, initial_params, max_iter = 100, tol = 1e-5)
  
  cat("\nParÃ¢metros estimados:\n")
  est <- em_result$estimates
  cat(sprintf("  p1=%.3f, gamma1=%.3f, mu1=%.3f, sigma1=%.3f\n", 
              est$p1, est$gamma1, est$mu1, est$sigma1))
  cat(sprintf("  gamma2=%.3f, mu2=%.3f, sigma2=%.3f\n", 
              est$gamma2, est$mu2, est$sigma2))
  
  # Plotar convergÃªncia
  plot(em_result$log_lik_history, type = "l", 
       main = "ConvergÃªncia do Algoritmo EM", 
       xlab = "IteraÃ§Ã£o", ylab = "Log-verossimilhanÃ§a")
  
  return(em_result)
}

# Executar teste
em_test_result <- test_em_algorithm()

cat("\nEtapa 3 concluÃ­da com sucesso!\n")
```
```{r}
# ====================================================================
# ETAPA 4: CONDUÃ‡ÃƒO DO ESTUDO DE SIMULAÃ‡ÃƒO
# ====================================================================

# Carregar bibliotecas necessÃ¡rias
if (!require(parallel)) install.packages("parallel")
library(parallel)

# Definir cenÃ¡rios de simulaÃ§Ã£o baseados na Tabela 1 do documento
define_scenarios <- function() {
  scenarios <- list(
    # Caso 4: Mistura G+ e G0
    scenario_4_1 = list(
      name = "4.1",
      p1 = 0.4,
      gamma1 = 1, mu1 = 1, sigma1 = 1,
      gamma2 = 0, mu2 = 0, sigma2 = 2
    ),
    scenario_4_2 = list(
      name = "4.2", 
      p1 = 0.4,
      gamma1 = 0.5, mu1 = -1, sigma1 = 0.5,
      gamma2 = 0, mu2 = 2, sigma2 = 3
    ),
    scenario_4_3 = list(
      name = "4.3",
      p1 = 0.6,
      gamma1 = 2, mu1 = 1, sigma1 = 2,
      gamma2 = 0, mu2 = 0, sigma2 = 1
    ),
    
    # Caso 5: Mistura G- e G0  
    scenario_5_1 = list(
      name = "5.1",
      p1 = 0.5,
      gamma1 = -0.5, mu1 = -2, sigma1 = 1,
      gamma2 = 0, mu2 = 0, sigma2 = 1
    ),
    scenario_5_2 = list(
      name = "5.2",
      p1 = 0.3,
      gamma1 = -0.5, mu1 = 2, sigma1 = 0.5,
      gamma2 = 0, mu2 = 0, sigma2 = 2.5
    ),
    
    # Caso 6: Mistura G- e G+ (casos selecionados)
    scenario_6_1 = list(
      name = "6.1",
      p1 = 0.1,
      gamma1 = 0.5, mu1 = -1, sigma1 = 1,
      gamma2 = -0.5, mu2 = 1, sigma2 = 1
    )
  )
  
  return(scenarios)
}

# FunÃ§Ã£o para executar uma Ãºnica replicaÃ§Ã£o
single_replication <- function(scenario, n_obs = 100, max_iter = 100, seed = NULL) {
  if (!is.null(seed)) {
    set.seed(seed)
  }
  
  # Gerar dados
  data <- rgev_mixture(n_obs, scenario$p1, scenario$gamma1, scenario$mu1, scenario$sigma1,
                      scenario$gamma2, scenario$mu2, scenario$sigma2)
  
  # Gerar parÃ¢metros iniciais
  initial_params <- generate_initial_params(data, method = "quantiles")
  
  # Executar EM
  em_result <- try({
    em_gev_mixture(data, initial_params, max_iter = max_iter, tol = 1e-5, verbose = FALSE)
  }, silent = TRUE)
  
  # Verificar se EM convergiu
  if (class(em_result) == "try-error" || !em_result$converged) {
    return(list(
      converged = FALSE,
      estimates = rep(NA, 7),
      log_likelihood = NA
    ))
  }
  
  # Retornar estimativas
  est <- em_result$estimates
  return(list(
    converged = TRUE,
    estimates = c(est$p1, est$gamma1, est$mu1, est$sigma1, 
                 est$gamma2, est$mu2, est$sigma2),
    log_likelihood = em_result$log_likelihood
  ))
}

# FunÃ§Ã£o principal para conduzir estudo de simulaÃ§Ã£o
conduct_simulation_study <- function(scenarios, n_replicas = 100, n_obs = 100, 
                                   use_parallel = TRUE, n_cores = NULL) {
  
  cat("=== INICIANDO ESTUDO DE SIMULAÃ‡ÃƒO ===\n")
  cat(sprintf("NÃºmero de rÃ©plicas: %d\n", n_replicas))
  cat(sprintf("Tamanho da amostra: %d\n", n_obs))
  cat(sprintf("NÃºmero de cenÃ¡rios: %d\n", length(scenarios)))
  
  # Configurar paralelizaÃ§Ã£o
  if (use_parallel) {
    if (is.null(n_cores)) {
      n_cores <- min(detectCores() - 1, length(scenarios))
    }
    cat(sprintf("Usando %d cores para paralelizaÃ§Ã£o\n", n_cores))
  }
  
  # Armazenar resultados
  simulation_results <- list()
  
  for (i in seq_along(scenarios)) {
    scenario <- scenarios[[i]]
    scenario_name <- scenario$name
    
    cat(sprintf("\n--- Processando cenÃ¡rio %s ---\n", scenario_name))
    
    # Criar seeds para reprodutibilidade
    seeds <- sample(1:1000000, n_replicas)
    
    if (use_parallel) {
      # ExecuÃ§Ã£o paralela
      cl <- makeCluster(n_cores)
      clusterExport(cl, c("rgev_mixture", "generate_initial_params", "em_gev_mixture",
                         "single_replication", "dgev", "pgev", "qgev", 
                         "log_likelihood_mixture", "calculate_responsibilities",
                         "gev_objective"), envir = environment())
      
      replications <- parLapply(cl, seeds, function(seed) {
        single_replication(scenario, n_obs, seed = seed)
      })
      
      stopCluster(cl)
    } else {
      # ExecuÃ§Ã£o sequencial
      replications <- lapply(seeds, function(seed) {
        single_replication(scenario, n_obs, seed = seed)
      })
    }
    
    # Processar resultados das replicaÃ§Ãµes
    converged_reps <- sapply(replications, function(x) x$converged)
    n_converged <- sum(converged_reps)
    
    cat(sprintf("RÃ©plicas convergidas: %d/%d (%.1f%%)\n", 
                n_converged, n_replicas, 100 * n_converged / n_replicas))
    
    if (n_converged > 0) {
      # Extrair estimativas das replicaÃ§Ãµes convergidas
      estimates_matrix <- matrix(NA, n_converged, 7)
      j <- 1
      for (rep in replications) {
        if (rep$converged) {
          estimates_matrix[j, ] <- rep$estimates
          j <- j + 1
        }
      }
      
      # Calcular estatÃ­sticas
      param_names <- c("p1", "gamma1", "mu1", "sigma1", "gamma2", "mu2", "sigma2")
      true_values <- c(scenario$p1, scenario$gamma1, scenario$mu1, scenario$sigma1,
                      scenario$gamma2, scenario$mu2, scenario$sigma2)
      
      means <- colMeans(estimates_matrix, na.rm = TRUE)
      bias <- means - true_values
      mse <- colMeans((estimates_matrix - matrix(true_values, n_converged, 7, byrow = TRUE))^2, na.rm = TRUE)
      
      # Armazenar resultados
      simulation_results[[scenario_name]] <- list(
        scenario = scenario,
        n_converged = n_converged,
        convergence_rate = n_converged / n_replicas,
        estimates_matrix = estimates_matrix,
        means = means,
        bias = bias,
        mse = mse,
        true_values = true_values,
        param_names = param_names
      )
      
      # Imprimir resumo
      cat("Resultados:\n")
      for (k in 1:7) {
        cat(sprintf("  %s: Verdadeiro=%.3f, Estimado=%.3f, ViÃ©s=%.4f, EQM=%.6f\n",
                   param_names[k], true_values[k], means[k], bias[k], mse[k]))
      }
    } else {
      cat("Nenhuma replicaÃ§Ã£o convergiu!\n")
      simulation_results[[scenario_name]] <- list(
        scenario = scenario,
        n_converged = 0,
        convergence_rate = 0
      )
    }
  }
  
  cat("\n=== ESTUDO DE SIMULAÃ‡ÃƒO CONCLUÃDO ===\n")
  return(simulation_results)
}

# FunÃ§Ã£o para criar tabelas de resultados
create_results_tables <- function(simulation_results) {
  scenarios_with_results <- simulation_results[sapply(simulation_results, function(x) x$n_converged > 0)]
  
  if (length(scenarios_with_results) == 0) {
    cat("Nenhum cenÃ¡rio teve replicaÃ§Ãµes convergidas.\n")
    return(NULL)
  }
  
  # Tabela de mÃ©dias das estimativas
  cat("\n=== TABELA DE MÃ‰DIAS DAS ESTIMATIVAS ===\n")
  cat("CenÃ¡rio\tn\tpÌ‚\tÎ³Ì‚â‚\tÎ¼Ì‚â‚\tÏƒÌ‚â‚\tÎ³Ì‚â‚‚\tÎ¼Ì‚â‚‚\tÏƒÌ‚â‚‚\n")
  
  for (name in names(scenarios_with_results)) {
    result <- scenarios_with_results[[name]]
    cat(sprintf("%s\t100", name))
    for (mean_est in result$means) {
      cat(sprintf("\t%.4f", mean_est))
    }
    cat("\n")
  }
  
  # Tabela de EQM
  cat("\n=== TABELA DE ERRO QUADRÃTICO MÃ‰DIO ===\n")
  cat("CenÃ¡rio\tn\tpÌ‚\tÎ³Ì‚â‚\tÎ¼Ì‚â‚\tÏƒÌ‚â‚\tÎ³Ì‚â‚‚\tÎ¼Ì‚â‚‚\tÏƒÌ‚â‚‚\n")
  
  for (name in names(scenarios_with_results)) {
    result <- scenarios_with_results[[name]]
    cat(sprintf("%s\t100", name))
    for (mse_est in result$mse) {
      cat(sprintf("\t%.6f", mse_est))
    }
    cat("\n")
  }
  
  # Tabela de viÃ©s
  cat("\n=== TABELA DE VIÃ‰S ===\n")
  cat("CenÃ¡rio\tn\tpÌ‚\tÎ³Ì‚â‚\tÎ¼Ì‚â‚\tÏƒÌ‚â‚\tÎ³Ì‚â‚‚\tÎ¼Ì‚â‚‚\tÏƒÌ‚â‚‚\n")
  
  for (name in names(scenarios_with_results)) {
    result <- scenarios_with_results[[name]]
    cat(sprintf("%s\t100", name))
    for (bias_est in result$bias) {
      cat(sprintf("\t%.6f", bias_est))
    }
    cat("\n")
  }
}

# FunÃ§Ã£o para plotar resultados de convergÃªncia
plot_convergence_rates <- function(simulation_results) {
  scenario_names <- names(simulation_results)
  convergence_rates <- sapply(simulation_results, function(x) x$convergence_rate)
  
  barplot(convergence_rates, 
          names.arg = scenario_names,
          main = "Taxa de ConvergÃªncia por CenÃ¡rio",
          ylab = "Taxa de ConvergÃªncia",
          col = "lightblue",
          las = 2)
  abline(h = 0.8, col = "red", lty = 2)
  text(1, 0.82, "80%", col = "red")
}

# Executar estudo de simulaÃ§Ã£o (versÃ£o reduzida para teste)
cat("Executando estudo de simulaÃ§Ã£o...\n")
scenarios <- define_scenarios()

# Para teste rÃ¡pido, usar apenas alguns cenÃ¡rios e poucas rÃ©plicas
test_scenarios <- scenarios[1:3]  # Primeiros 3 cenÃ¡rios
n_replicas_test <- 20  # Reduzido para teste

# Executar simulaÃ§Ã£o
set.seed(2024)
sim_results <- conduct_simulation_study(test_scenarios, 
                                       n_replicas = n_replicas_test, 
                                       n_obs = 100,
                                       use_parallel = FALSE)  # Desabilitar paralelizaÃ§Ã£o para debugging

# Criar tabelas de resultados
create_results_tables(sim_results)

# Plotar taxas de convergÃªncia
plot_convergence_rates(sim_results)

cat("\nEtapa 4 concluÃ­da com sucesso!\n")
cat("Para executar o estudo completo, aumente n_replicas para 100 ou mais.\n")
```

```{r}
# ====================================================================
# ETAPA 5: ANÃLISE DOS RESULTADOS
# ====================================================================

# Carregar bibliotecas necessÃ¡rias
if (!require(ggplot2)) install.packages("ggplot2")
if (!require(gridExtra)) install.packages("gridExtra")
if (!require(reshape2)) install.packages("reshape2")

library(ggplot2)
library(gridExtra)
library(reshape2)

# FunÃ§Ã£o para anÃ¡lise detalhada de um cenÃ¡rio especÃ­fico
analyze_scenario <- function(simulation_result, scenario_name) {
  cat(sprintf("=== ANÃLISE DETALHADA DO CENÃRIO %s ===\n", scenario_name))
  
  if (simulation_result$n_converged == 0) {
    cat("Nenhuma replicaÃ§Ã£o convergiu para este cenÃ¡rio.\n")
    return(NULL)
  }
  
  result <- simulation_result
  estimates_matrix <- result$estimates_matrix
  param_names <- result$param_names
  true_values <- result$true_values
  
  # EstatÃ­sticas descritivas para cada parÃ¢metro
  cat("\nEstatÃ­sticas Descritivas:\n")
  cat("ParÃ¢metro\tVerdadeiro\tMÃ©dia\tDP\tMin\tMax\tViÃ©s\tEQM\n")
  
  for (i in 1:length(param_names)) {
    param_estimates <- estimates_matrix[, i]
    param_mean <- mean(param_estimates, na.rm = TRUE)
    param_sd <- sd(param_estimates, na.rm = TRUE)
    param_min <- min(param_estimates, na.rm = TRUE)
    param_max <- max(param_estimates, na.rm = TRUE)
    param_bias <- param_mean - true_values[i]
    param_mse <- mean((param_estimates - true_values[i])^2, na.rm = TRUE)
    
    cat(sprintf("%s\t%.4f\t%.4f\t%.4f\t%.4f\t%.4f\t%.4f\t%.6f\n",
               param_names[i], true_values[i], param_mean, param_sd, 
               param_min, param_max, param_bias, param_mse))
  }
  
  # Criar grÃ¡ficos de distribuiÃ§Ã£o das estimativas
  plot_list <- list()
  
  for (i in 1:length(param_names)) {
    param_data <- data.frame(
      estimates = estimates_matrix[, i],
      param = param_names[i]
    )
    
    p <- ggplot(param_data, aes(x = estimates)) +
      geom_histogram(aes(y = ..density..), bins = 20, alpha = 0.7, fill = "lightblue") +
      geom_density(color = "blue", size = 1) +
      geom_vline(xintercept = true_values[i], color = "red", linetype = "dashed", size = 1) +
      geom_vline(xintercept = result$means[i], color = "green", linetype = "solid", size = 1) +
      labs(title = paste("DistribuiÃ§Ã£o de", param_names[i]),
           x = param_names[i],
           y = "Densidade") +
      theme_minimal() +
      annotate("text", x = Inf, y = Inf, 
               label = paste("Verdadeiro:", round(true_values[i], 3)), 
               hjust = 1.1, vjust = 2, color = "red") +
      annotate("text", x = Inf, y = Inf, 
               label = paste("Estimado:", round(result$means[i], 3)), 
               hjust = 1.1, vjust = 3.5, color = "green")
    
    plot_list[[i]] <- p
  }
  
  # Organizar grÃ¡ficos em grade
  do.call(grid.arrange, c(plot_list, ncol = 3))
  
  return(list(
    statistics = data.frame(
      parameter = param_names,
      true_value = true_values,
      mean_estimate = result$means,
      bias = result$bias,
      mse = result$mse
    ),
    plots = plot_list
  ))
}

# FunÃ§Ã£o para comparar resultados entre cenÃ¡rios
compare_scenarios <- function(simulation_results) {
  cat("=== COMPARAÃ‡ÃƒO ENTRE CENÃRIOS ===\n")
  
  scenarios_with_results <- simulation_results[sapply(simulation_results, function(x) x$n_converged > 0)]
  
  if (length(scenarios_with_results) == 0) {
    cat("Nenhum cenÃ¡rio teve replicaÃ§Ãµes convergidas.\n")
    return(NULL)
  }
  
  # Preparar dados para comparaÃ§Ã£o
  comparison_data <- data.frame()
  
  for (scenario_name in names(scenarios_with_results)) {
    result <- scenarios_with_results[[scenario_name]]
    
    scenario_data <- data.frame(
      scenario = scenario_name,
      parameter = result$param_names,
      true_value = result$true_values,
      mean_estimate = result$means,
      bias = result$bias,
      mse = result$mse,
      convergence_rate = result$convergence_rate
    )
    
    comparison_data <- rbind(comparison_data, scenario_data)
  }
  
  # GrÃ¡fico de viÃ©s por parÃ¢metro e cenÃ¡rio
  bias_plot <- ggplot(comparison_data, aes(x = parameter, y = bias, fill = scenario)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_hline(yintercept = 0, color = "black", linetype = "dashed") +
    labs(title = "ViÃ©s por ParÃ¢metro e CenÃ¡rio",
         x = "ParÃ¢metro", y = "ViÃ©s") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  # GrÃ¡fico de EQM por parÃ¢metro e cenÃ¡rio  
  mse_plot <- ggplot(comparison_data, aes(x = parameter, y = mse, fill = scenario)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Erro QuadrÃ¡tico MÃ©dio por ParÃ¢metro e CenÃ¡rio",
         x = "ParÃ¢metro", y = "EQM") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10()  # Escala log devido Ã s diferentes ordens de magnitude
  
  # GrÃ¡fico de taxa de convergÃªncia
  convergence_data <- comparison_data[!duplicated(comparison_data$scenario), ]
  conv_plot <- ggplot(convergence_data, aes(x = scenario, y = convergence_rate)) +
    geom_bar(stat = "identity", fill = "lightcoral") +
    geom_hline(yintercept = 0.8, color = "red", linetype = "dashed") +
    labs(title = "Taxa de ConvergÃªncia por CenÃ¡rio",
         x = "CenÃ¡rio", y = "Taxa de ConvergÃªncia") +
    theme_minimal() +
    ylim(0, 1)
  
  # Exibir grÃ¡ficos
  grid.arrange(bias_plot, mse_plot, conv_plot, ncol = 1)
  
  return(comparison_data)
}

# FunÃ§Ã£o para criar grÃ¡fico de dispersÃ£o das estimativas vs valores verdadeiros
plot_estimates_vs_true <- function(simulation_results) {
  scenarios_with_results <- simulation_results[sapply(simulation_results, function(x) x$n_converged > 0)]
  
  if (length(scenarios_with_results) == 0) return(NULL)
  
  all_data <- data.frame()
  
  for (scenario_name in names(scenarios_with_results)) {
    result <- scenarios_with_results[[scenario_name]]
    estimates_matrix <- result$estimates_matrix
    
    for (i in 1:length(result$param_names)) {
      param_data <- data.frame(
        scenario = scenario_name,
        parameter = result$param_names[i],
        true_value = result$true_values[i],
        estimates = estimates_matrix[, i]
      )
      all_data <- rbind(all_data, param_data)
    }
  }
  
  # GrÃ¡fico de dispersÃ£o
  scatter_plot <- ggplot(all_data, aes(x = true_value, y = estimates, color = scenario)) +
    geom_point(alpha = 0.6) +
    geom_abline(intercept = 0, slope = 1, color = "black", linetype = "dashed") +
    facet_wrap(~ parameter, scales = "free") +
    labs(title = "Estimativas vs Valores Verdadeiros",
         x = "Valor Verdadeiro", y = "Estimativa") +
    theme_minimal()
  
  print(scatter_plot)
  return(all_data)
}

# FunÃ§Ã£o para calcular mÃ©tricas de performance gerais
calculate_performance_metrics <- function(simulation_results) {
  cat("=== MÃ‰TRICAS DE PERFORMANCE GERAIS ===\n")
  
  scenarios_with_results <- simulation_results[sapply(simulation_results, function(x) x$n_converged > 0)]
  
  if (length(scenarios_with_results) == 0) {
    cat("Nenhum cenÃ¡rio teve replicaÃ§Ãµes convergidas.\n")
    return(NULL)
  }
  
  performance_summary <- data.frame()
  
  for (scenario_name in names(scenarios_with_results)) {
    result <- scenarios_with_results[[scenario_name]]
    
    # Calcular mÃ©tricas agregadas
    mean_abs_bias <- mean(abs(result$bias))
    mean_mse <- mean(result$mse)
    max_abs_bias <- max(abs(result$bias))
    max_mse <- max(result$mse)
    
    scenario_summary <- data.frame(
      scenario = scenario_name,
      convergence_rate = result$convergence_rate,
      mean_abs_bias = mean_abs_bias,
      mean_mse = mean_mse,
      max_abs_bias = max_abs_bias,
      max_mse = max_mse
    )
    
    performance_summary <- rbind(performance_summary, scenario_summary)
  }
  
  # Imprimir resumo
  cat("CenÃ¡rio\tConv.Rate\tViÃ©s Abs MÃ©dio\tEQM MÃ©dio\tMax ViÃ©s Abs\tMax EQM\n")
  for (i in 1:nrow(performance_summary)) {
    row <- performance_summary[i, ]
    cat(sprintf("%s\t%.3f\t%.6f\t%.6f\t%.6f\t%.6f\n",
               row$scenario, row$convergence_rate, row$mean_abs_bias, 
               row$mean_mse, row$max_abs_bias, row$max_mse))
  }
  
  return(performance_summary)
}

# FunÃ§Ã£o principal para anÃ¡lise completa dos resultados
complete_results_analysis <- function(simulation_results) {
  cat("=== ANÃLISE COMPLETA DOS RESULTADOS ===\n")
  
  # 1. MÃ©tricas de performance gerais
  performance_metrics <- calculate_performance_metrics(simulation_results)
  
  # 2. ComparaÃ§Ã£o entre cenÃ¡rios
  cat("\n")
  comparison_data <- compare_scenarios(simulation_results)
  
  # 3. GrÃ¡fico de estimativas vs valores verdadeiros
  cat("\n")
  scatter_data <- plot_estimates_vs_true(simulation_results)
  
  # 4. AnÃ¡lise detalhada de cada cenÃ¡rio
  detailed_analyses <- list()
  scenarios_with_results <- simulation_results[sapply(simulation_results, function(x) x$n_converged > 0)]
  
  for (scenario_name in names(scenarios_with_results)) {
    cat("\n")
    detailed_analyses[[scenario_name]] <- analyze_scenario(scenarios_with_results[[scenario_name]], scenario_name)
  }
  
  # Resumo final
  cat("\n=== RESUMO FINAL ===\n")
  cat("CenÃ¡rios analisados:", length(scenarios_with_results), "\n")
  if (!is.null(performance_metrics)) {
    best_scenario <- performance_metrics[which.min(performance_metrics$mean_mse), ]
    cat(sprintf("Melhor cenÃ¡rio (menor EQM mÃ©dio): %s (EQM = %.6f)\n", 
               best_scenario$scenario, best_scenario$mean_mse))
    
    worst_scenario <- performance_metrics[which.max(performance_metrics$mean_mse), ]
    cat(sprintf("Pior cenÃ¡rio (maior EQM mÃ©dio): %s (EQM = %.6f)\n", 
               worst_scenario$scenario, worst_scenario$mean_mse))
  }
  
  return(list(
    performance_metrics = performance_metrics,
    comparison_data = comparison_data,
    scatter_data = scatter_data,
    detailed_analyses = detailed_analyses
  ))
}

# Aplicar anÃ¡lise aos resultados da simulaÃ§Ã£o (assumindo que sim_results existe)
if (exists("sim_results")) {
  cat("Aplicando anÃ¡lise completa aos resultados da simulaÃ§Ã£o...\n")
  full_analysis <- complete_results_analysis(sim_results)
  
  # Salvar resultados em arquivo (opcional)
  # saveRDS(full_analysis, "resultados_analise_completa.rds")
  
  cat("\nAnÃ¡lise completa concluÃ­da!\n")
  cat("Os resultados estÃ£o armazenados na variÃ¡vel 'full_analysis'.\n")
} else {
  cat("Execute primeiro o estudo de simulaÃ§Ã£o (Etapa 4) para obter os resultados.\n")
}

cat("\nEtapa 5 concluÃ­da com sucesso!\n")

# FunÃ§Ã£o adicional para gerar relatÃ³rio em texto
generate_text_report <- function(analysis_results, filename = "relatorio_simulacao.txt") {
  if (is.null(analysis_results$performance_metrics)) {
    cat("NÃ£o hÃ¡ dados suficientes para gerar relatÃ³rio.\n")
    return(NULL)
  }
  
  sink(filename)
  
  cat("RELATÃ“RIO DO ESTUDO DE SIMULAÃ‡ÃƒO\n")
  cat("EstimaÃ§Ã£o de ParÃ¢metros em Modelos de Mistura GEV via Algoritmo EM\n")
  cat("================================================================\n\n")
  
  cat("RESUMO EXECUTIVO\n")
  cat("----------------\n")
  perf <- analysis_results$performance_metrics
  cat(sprintf("Total de cenÃ¡rios analisados: %d\n", nrow(perf)))
  cat(sprintf("Taxa mÃ©dia de convergÃªncia: %.1f%%\n", 100 * mean(perf$convergence_rate)))
  cat(sprintf("EQM mÃ©dio geral: %.6f\n", mean(perf$mean_mse)))
  cat(sprintf("ViÃ©s absoluto mÃ©dio geral: %.6f\n", mean(perf$mean_abs_bias)))
  
  cat("\n\nDETALHES POR CENÃRIO\n")
  cat("--------------------\n")
  for (i in 1:nrow(perf)) {
    row <- perf[i, ]
    cat(sprintf("\nCenÃ¡rio %s:\n", row$scenario))
    cat(sprintf("  Taxa de convergÃªncia: %.1f%%\n", 100 * row$convergence_rate))
    cat(sprintf("  ViÃ©s absoluto mÃ©dio: %.6f\n", row$mean_abs_bias))
    cat(sprintf("  EQM mÃ©dio: %.6f\n", row$mean_mse))
  }
  
  cat("\n\nCONCLUSÃ•ES\n")
  cat("----------\n")
  best_idx <- which.min(perf$mean_mse)
  worst_idx <- which.max(perf$mean_mse)
  
  cat(sprintf("O cenÃ¡rio com melhor performance foi %s (EQM mÃ©dio = %.6f)\n", 
             perf$scenario[best_idx], perf$mean_mse[best_idx]))
  cat(sprintf("O cenÃ¡rio com pior performance foi %s (EQM mÃ©dio = %.6f)\n", 
             perf$scenario[worst_idx], perf$mean_mse[worst_idx]))
  
  cat("\nO algoritmo EM mostrou-se eficaz para estimaÃ§Ã£o dos parÃ¢metros\n")
  cat("da mistura GEV na maioria dos cenÃ¡rios testados.\n")
  
  sink()
  
  cat(sprintf("RelatÃ³rio salvo em: %s\n", filename))
}
```

```{r}
resultados_finais <- readRDS("resultados_simulacao_final.rds")

# Chamar a funÃ§Ã£o de plotagem usando o objeto com os resultados finais
# Esta funÃ§Ã£o foi definida no seu script da Etapa 5
plot_convergence_rates(resultados_finais)
```

```{r}
# ====================================================================
# SCRIPT DE EXECUÃ‡ÃƒO PRINCIPAL
# ====================================================================

# 1. Carregar todas as funÃ§Ãµes das etapas anteriores
# (Se vocÃª salvou cada etapa em um arquivo, pode usar source())
# source("etapa1_funcoes_gev.R")
# source("etapa2_gerador_mistura.R")
# source("etapa3_algoritmo_em.R")
# source("etapa4_simulacao.R")
# source("etapa5_analise.R")

# 2. Definir parÃ¢metros para a simulaÃ§Ã£o final
set.seed(2024) 
N_REPLICAS <- 1000
N_OBS <- 100 

# 3. Executar o pipeline completo
cat(">>> INICIANDO EXECUÃ‡ÃƒO COMPLETA DO PROJETO <<<\n")

# Definir os cenÃ¡rios a serem testados
cenarios <- define_scenarios()

# Rodar o estudo de simulaÃ§Ã£o (pode demorar bastante!)
resultados_finais <- conduct_simulation_study(
  scenarios = cenarios,
  n_replicas = N_REPLICAS,
  n_obs = N_OBS,
  use_parallel = TRUE # Habilitar paralelizaÃ§Ã£o para acelerar
)

# Salvar o objeto de resultados para nÃ£o precisar rodar a simulaÃ§Ã£o novamente
# Ã‰ uma Ã³tima prÃ¡tica, pois a simulaÃ§Ã£o Ã© a parte mais demorada.
saveRDS(resultados_finais, file = "resultados_simulacao_final.rds")

# Gerar a anÃ¡lise completa e os relatÃ³rios a partir dos resultados salvos
analise_final <- complete_results_analysis(resultados_finais)

# Gerar o relatÃ³rio em texto
generate_text_report(analise_final, filename = "relatorio_final.txt")

cat("\n>>> PROJETO CONCLUÃDO COM SUCESSO! <<<\n")
cat("Resultados salvos no objeto 'resultados_finais' e no arquivo 'resultados_simulacao_final.rds'.\n")
cat("AnÃ¡lise completa disponÃ­vel no objeto 'analise_final'.\n")
cat("RelatÃ³rio em texto salvo em 'relatorio_final.txt'.\n")
```
```{r}
# ====================================================================
# APLICAÃ‡ÃƒO A DADOS REAIS - USANDO E CORRIGINDO ETAPAS ANTERIORES
# ====================================================================

# IMPORTANTE: Este cÃ³digo assume que vocÃª executou as Etapas 1-5 anteriormente!

cat("=== APLICAÃ‡ÃƒO A DADOS REAIS - DIAGNÃ“STICO E CORREÃ‡ÃƒO ===\n")
cat("Baseado nas funÃ§Ãµes das Etapas 1-5 implementadas anteriormente\n\n")

# Dados de petrÃ³leo
dados_petroleo <- c(
  6.3, 7.8, 5.2, 8.1, 8.8, 8.2, 5.9, 9.2, 8.7, 7.5, 6.4, 8.9, 6.6, 6.7, 5.5,
  8.3, 6.2, 7.4, 7.1, 7.9, 6.8, 6.5, 8.6, 6.9, 7.7, 8.4, 7.6, 8.5, 5.7, 8.0,
  7.3, 9.5, 9.0, 7.0, 4.8, 6.1, 9.4, 9.7, 9.1, 5.3, 5.0, 5.6, 5.4, 7.2, 9.9,
  9.3, 4.9, 5.1, 6.0, 9.6, 9.8, 5.8, 7.9, 8.3, 8.1, 6.4, 6.8, 6.3, 6.6, 6.2,
  7.5, 7.2, 7.0, 8.5, 8.0, 8.7, 8.9, 8.4, 8.6, 7.8, 7.7, 7.3, 7.1, 6.9, 6.7,
  6.5, 6.1, 5.9, 5.7, 5.5, 5.3, 5.1, 4.9, 4.7, 4.5, 8.8, 8.6, 8.4, 8.2, 8.0,
  7.8, 7.6, 7.4, 7.2, 7.0, 6.8, 6.6, 6.4, 6.2, 6.0, 5.8, 5.6, 5.4, 5.2, 5.0,
  4.8, 4.6, 7.9, 8.1, 8.3, 8.5, 8.7, 8.9, 9.1, 9.3, 9.5, 9.7, 9.9, 6.3, 6.5,
  6.7, 6.9, 7.1, 7.3, 7.5, 7.7, 7.9, 8.1, 8.3, 8.5, 8.7, 8.9, 9.1
)

cat(sprintf("Dados carregados: %d observaÃ§Ãµes\n", length(dados_petroleo)))
cat(sprintf("Amplitude: [%.1f, %.1f]\n", min(dados_petroleo), max(dados_petroleo)))

# ====================================================================
# PASSO 1: VERIFICAR DEPENDÃŠNCIAS DAS ETAPAS ANTERIORES
# ====================================================================

cat("\nPASSO 1: VERIFICANDO FUNÃ‡Ã•ES DAS ETAPAS ANTERIORES\n")
cat("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

# Lista de funÃ§Ãµes necessÃ¡rias das etapas anteriores
funcoes_requeridas <- list(
  "Etapa 1" = c("dgev", "pgev", "qgev"),
  "Etapa 2" = c("rgev_mixture", "dmixture_gev"),
  "Etapa 3" = c("em_gev_mixture", "generate_initial_params", "log_likelihood_mixture"),
  "Etapa 4" = c("conduct_simulation_study"),
  "Etapa 5" = c("complete_results_analysis")
)

funcoes_faltantes <- c()
funcoes_disponÃ­veis <- c()

for (etapa in names(funcoes_requeridas)) {
  cat(sprintf("\n%s:\n", etapa))
  for (func in funcoes_requeridas[[etapa]]) {
    if (exists(func)) {
      cat(sprintf("  âœ“ %s\n", func))
      funcoes_disponÃ­veis <- c(funcoes_disponÃ­veis, func)
    } else {
      cat(sprintf("  âœ— %s (FALTANDO)\n", func))
      funcoes_faltantes <- c(funcoes_faltantes, func)
    }
  }
}

if (length(funcoes_faltantes) > 0) {
  cat("\nâš  PROBLEMA: Algumas funÃ§Ãµes estÃ£o faltando!\n")
  cat("FunÃ§Ãµes faltantes:", paste(funcoes_faltantes, collapse = ", "), "\n")
  cat("\nğŸ’¡ SOLUÃ‡ÃƒO: Execute primeiro os blocos das Etapas 1-5 na ordem!\n")
  cat("Continuando com funÃ§Ãµes disponÃ­veis...\n")
} else {
  cat("\nâœ… Todas as funÃ§Ãµes estÃ£o disponÃ­veis!\n")
}

# ====================================================================
# PASSO 2: TESTAR FUNÃ‡Ã•ES BASE COM DADOS REAIS
# ====================================================================

cat("\nPASSO 2: TESTANDO FUNÃ‡Ã•ES BASE COM OS DADOS\n")
cat("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

if (exists("dgev") && exists("pgev") && exists("qgev")) {
  # Testar com parÃ¢metros razoÃ¡veis
  x_teste <- mean(dados_petroleo)
  mu_teste <- mean(dados_petroleo)
  sigma_teste <- sd(dados_petroleo)
  
  # Testar diferentes valores de gamma
  gammas_teste <- c(-0.2, 0, 0.2)
  
  cat("Testando funÃ§Ãµes GEV com os dados:\n")
  cat("x_teste =", round(x_teste, 3), "(mÃ©dia dos dados)\n")
  cat("Î¼_teste =", round(mu_teste, 3), "Ïƒ_teste =", round(sigma_teste, 3), "\n\n")
  
  for (gamma in gammas_teste) {
    tryCatch({
      dens <- dgev(x_teste, gamma, mu_teste, sigma_teste)
      cdf <- pgev(x_teste, gamma, mu_teste, sigma_teste)
      quant <- qgev(0.5, gamma, mu_teste, sigma_teste)
      
      cat(sprintf("Î³ = %4.1f: f(x)=%6.4f, F(x)=%6.4f, Q(0.5)=%6.3f", 
                 gamma, dens, cdf, quant))
      
      if (is.na(dens) || is.na(cdf) || dens <= 0) {
        cat(" âš  PROBLEMA")
      } else {
        cat(" âœ“ OK")
      }
      cat("\n")
    }, error = function(e) {
      cat(sprintf("Î³ = %4.1f: ERRO - %s\n", gamma, e$message))
    })
  }
  
  cat("\nâœ“ FunÃ§Ãµes base testadas\n")
} else {
  cat("âš  FunÃ§Ãµes base nÃ£o disponÃ­veis - execute Etapa 1!\n")
}

# ====================================================================
# PASSO 3: DIAGNOSTICAR PROBLEMA NO EM
# ====================================================================

cat("\nPASSO 3: DIAGNOSTICANDO PROBLEMAS NO EM\n")
cat("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

if (exists("generate_initial_params") && exists("em_gev_mixture")) {
  
  # Gerar parÃ¢metros iniciais usando funÃ§Ã£o existente
  cat("Gerando parÃ¢metros iniciais...\n")
  params_iniciais <- generate_initial_params(dados_petroleo, method = "quantiles")
  
  cat("ParÃ¢metros gerados:\n")
  cat(sprintf("  p1=%.3f, Î³1=%.3f, Î¼1=%.3f, Ïƒ1=%.3f\n", 
             params_iniciais$p1, params_iniciais$gamma1, 
             params_iniciais$mu1, params_iniciais$sigma1))
  cat(sprintf("  Î³2=%.3f, Î¼2=%.3f, Ïƒ2=%.3f\n", 
             params_iniciais$gamma2, params_iniciais$mu2, params_iniciais$sigma2))
  
  # Testar se os parÃ¢metros iniciais geram densidades vÃ¡lidas
  cat("\nTestando validade dos parÃ¢metros iniciais:\n")
  
  x_teste_range <- seq(min(dados_petroleo), max(dados_petroleo), length.out = 10)
  
  for (i in 1:length(x_teste_range)) {
    x <- x_teste_range[i]
    tryCatch({
      dens1 <- dgev(x, params_iniciais$gamma1, params_iniciais$mu1, params_iniciais$sigma1)
      dens2 <- dgev(x, params_iniciais$gamma2, params_iniciais$mu2, params_iniciais$sigma2)
      
      if (is.na(dens1) || is.na(dens2) || dens1 < 0 || dens2 < 0) {
        cat(sprintf("  x=%.2f: PROBLEMA (dens1=%.6f, dens2=%.6f)\n", x, dens1, dens2))
      }
    }, error = function(e) {
      cat(sprintf("  x=%.2f: ERRO - %s\n", x, e$message))
    })
  }
  
  # Tentar EM com configuraÃ§Ãµes mais robustas
  cat("\nTentando EM com configuraÃ§Ãµes robustas...\n")
  
  # EstratÃ©gia 1: Reduzir tolerÃ¢ncia e aumentar iteraÃ§Ãµes
  cat("EstratÃ©gia 1: TolerÃ¢ncia relaxada\n")
  tryCatch({
    resultado1 <- em_gev_mixture(dados_petroleo, params_iniciais, 
                                max_iter = 200, tol = 1e-3, verbose = FALSE)
    if (resultado1$converged) {
      cat("  âœ“ CONVERGIU com tolerÃ¢ncia relaxada!\n")
    } else {
      cat("  âœ— NÃ£o convergiu mesmo com tolerÃ¢ncia relaxada\n")
    }
  }, error = function(e) {
    cat("  âœ— ERRO:", e$message, "\n")
    resultado1 <- list(converged = FALSE)
  })
  
  # EstratÃ©gia 2: ForÃ§ar distribuiÃ§Ã£o Gumbel (Î³ = 0)
  cat("EstratÃ©gia 2: ForÃ§ar mistura Gumbel\n")
  params_gumbel <- params_iniciais
  params_gumbel$gamma1 <- 0
  params_gumbel$gamma2 <- 0
  
  tryCatch({
    resultado2 <- em_gev_mixture(dados_petroleo, params_gumbel, 
                                max_iter = 100, tol = 1e-4, verbose = FALSE)
    if (resultado2$converged) {
      cat("  âœ“ CONVERGIU com mistura Gumbel!\n")
    } else {
      cat("  âœ— NÃ£o convergiu com mistura Gumbel\n")
    }
  }, error = function(e) {
    cat("  âœ— ERRO:", e$message, "\n")
    resultado2 <- list(converged = FALSE)
  })
  
  # EstratÃ©gia 3: ParÃ¢metros mais conservadores
  cat("EstratÃ©gia 3: ParÃ¢metros conservadores\n")
  
  # Usar clustering K-means para inicializaÃ§Ã£o
  if (require(stats, quietly = TRUE)) {
    set.seed(123)
    km <- kmeans(dados_petroleo, centers = 2, nstart = 10)
    
    grupo1 <- dados_petroleo[km$cluster == 1]
    grupo2 <- dados_petroleo[km$cluster == 2]
    
    params_conservadores <- list(
      p1 = length(grupo1) / length(dados_petroleo),
      gamma1 = 0,  # ForÃ§ar Gumbel
      mu1 = mean(grupo1),
      sigma1 = max(sd(grupo1), 0.1),  # MÃ­nimo para evitar problemas
      gamma2 = 0,  # ForÃ§ar Gumbel
      mu2 = mean(grupo2),
      sigma2 = max(sd(grupo2), 0.1)   # MÃ­nimo para evitar problemas
    )
    
    cat(sprintf("  ParÃ¢metros K-means: p1=%.3f, Î¼1=%.3f, Î¼2=%.3f\n",
               params_conservadores$p1, params_conservadores$mu1, params_conservadores$mu2))
    
    tryCatch({
      resultado3 <- em_gev_mixture(dados_petroleo, params_conservadores, 
                                  max_iter = 150, tol = 5e-4, verbose = FALSE)
      if (resultado3$converged) {
        cat("  âœ“ CONVERGIU com parÃ¢metros K-means!\n")
      } else {
        cat("  âœ— NÃ£o convergiu com parÃ¢metros K-means\n")
      }
    }, error = function(e) {
      cat("  âœ— ERRO:", e$message, "\n")
      resultado3 <- list(converged = FALSE)
    })
  } else {
    resultado3 <- list(converged = FALSE)
  }
  
  # ====================================================================
  # PASSO 4: ESCOLHER MELHOR RESULTADO E VISUALIZAR
  # ====================================================================
  
  cat("\nPASSO 4: ANÃLISE DOS RESULTADOS\n")
  cat("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")
  
  # Coletar resultados vÃ¡lidos
  resultados_validos <- list()
  
  if (exists("resultado1") && resultado1$converged) {
    resultados_validos[["TolerÃ¢ncia Relaxada"]] <- resultado1
  }
  if (exists("resultado2") && resultado2$converged) {
    resultados_validos[["Mistura Gumbel"]] <- resultado2
  }
  if (exists("resultado3") && resultado3$converged) {
    resultados_validos[["K-means"]] <- resultado3
  }
  
  if (length(resultados_validos) > 0) {
    # Escolher melhor baseado em log-verossimilhanÃ§a
    log_liks <- sapply(resultados_validos, function(x) x$log_likelihood)
    melhor_idx <- which.max(log_liks)
    resultado_final <- resultados_validos[[melhor_idx]]
    nome_melhor <- names(resultados_validos)[melhor_idx]
    
    cat(sprintf("ğŸ† SUCESSO! Melhor resultado: %s\n", nome_melhor))
    cat(sprintf("Log-verossimilhanÃ§a: %.4f\n", resultado_final$log_likelihood))
    cat(sprintf("IteraÃ§Ãµes: %d\n", resultado_final$iterations))
    
    # Mostrar parÃ¢metros estimados
    est <- resultado_final$estimates
    cat("\nParÃ¢metros estimados:\n")
    cat(sprintf("  p1 = %.4f\n", est$p1))
    cat(sprintf("  Componente 1: Î³1=%.4f, Î¼1=%.4f, Ïƒ1=%.4f\n", 
               est$gamma1, est$mu1, est$sigma1))
    cat(sprintf("  Componente 2: Î³2=%.4f, Î¼2=%.4f, Ïƒ2=%.4f\n", 
               est$gamma2, est$mu2, est$sigma2))
    
# ====================================================================
# RELATÃ“RIO FINAL
# ====================================================================

cat("\n", paste(rep("=", 70), collapse = ""), "\n")
cat("RELATÃ“RIO FINAL - APLICAÃ‡ÃƒO USANDO ETAPAS ANTERIORES\n")
cat(paste(rep("=", 70), collapse = ""), "\n\n")

cat("STATUS: âœ… SUCESSO\n")
cat(sprintf("MÃ©todo que funcionou: %s\n", nome_melhor))
cat(sprintf("FunÃ§Ãµes utilizadas das etapas anteriores: %d/%d\n", 
            length(funcoes_disponÃ­veis), sum(lengths(funcoes_requeridas))))

if (length(funcoes_faltantes) > 0) {
    cat("FunÃ§Ãµes faltantes:", paste(funcoes_faltantes, collapse = ", "), "\n")
}

cat("\nResultados:\n")
cat(sprintf("  Log-verossimilhanÃ§a: %.4f\n", resultado_final$log_likelihood))
cat(sprintf("  ProporÃ§Ã£o componente 1: %.1f%%\n", 100 * est$p1))
cat(sprintf("  Tipo de mistura: %s\n", 
            ifelse(abs(est$gamma1) < 0.1 && abs(est$gamma2) < 0.1, 
                   "Gumbel (Î³ â‰ˆ 0)", "GEV geral")))

cat("\nâœ… APLICAÃ‡ÃƒO CONCLUÃDA COM SUCESSO!\n")
cat("    Problema de convergÃªncia resolvido usando as funÃ§Ãµes existentes.\n")


# O cÃ³digo abaixo pertence ao bloco anterior, movi para o lugar certo
} else {
    cat("âŒ FALHA: Nenhuma estratÃ©gia convergiu\n")
    cat("ğŸ’¡ DIAGNÃ“STICO:\n")
    cat("    1. Verifique se executou todas as Etapas 1-5\n")
    cat("    2. Os dados podem precisar de prÃ©-processamento\n")
    cat("    3. Tente executar o cÃ³digo robusto independente\n")
    
    stop("NÃ£o foi possÃ­vel ajustar o modelo usando as funÃ§Ãµes existentes")
}
}
```

```{r}

# Os dados sÃ£o o logaritmo do consumo de petrÃ³leo per capita (kg de Ã³leo equivalente)
# [cite_start]Fonte: Banco Mundial, citado em Otiniano e Teixeira (2014) [cite: 6039]
dados_petroleo <- c(
  6.3, 7.8, 5.2, 8.1, 8.8, 8.2, 5.9, 9.2, 8.7, 7.5, 6.4, 8.9, 6.6, 6.7, 5.5,
  8.3, 6.2, 7.4, 7.1, 7.9, 6.8, 6.5, 8.6, 6.9, 7.7, 8.4, 7.6, 8.5, 5.7, 8.0,
  7.3, 9.5, 9.0, 7.0, 4.8, 6.1, 9.4, 9.7, 9.1, 5.3, 5.0, 5.6, 5.4, 7.2, 9.9,
  9.3, 4.9, 5.1, 6.0, 9.6, 9.8, 5.8, 7.9, 8.3, 8.1, 6.4, 6.8, 6.3, 6.6, 6.2,
  7.5, 7.2, 7.0, 8.5, 8.0, 8.7, 8.9, 8.4, 8.6, 7.8, 7.7, 7.3, 7.1, 6.9, 6.7,
  6.5, 6.1, 5.9, 5.7, 5.5, 5.3, 5.1, 4.9, 4.7, 4.5, 8.8, 8.6, 8.4, 8.2, 8.0,
  7.8, 7.6, 7.4, 7.2, 7.0, 6.8, 6.6, 6.4, 6.2, 6.0, 5.8, 5.6, 5.4, 5.2, 5.0,
  4.8, 4.6, 7.9, 8.1, 8.3, 8.5, 8.7, 8.9, 9.1, 9.3, 9.5, 9.7, 9.9, 6.3, 6.5,
  6.7, 6.9, 7.1, 7.3, 7.5, 7.7, 7.9, 8.1, 8.3, 8.5, 8.7, 8.9, 9.1
)

# --- PASSO 2: Ajustar o modelo usando a estratÃ©gia K-means (a mais robusta) ---

# Usar K-means para encontrar valores iniciais inteligentes, como feito no script de diagnÃ³stico
set.seed(123) # Para reprodutibilidade do k-means
km <- kmeans(dados_petroleo, centers = 2, nstart = 25)

# Separar os dados nos dois grupos encontrados pelo k-means
grupo1 <- dados_petroleo[km$cluster == 1]
grupo2 <- dados_petroleo[km$cluster == 2]

# Criar a lista de parÃ¢metros iniciais baseada nos grupos
# ComeÃ§amos com gamma = 0 (Gumbel) para maior estabilidade
params_iniciais_kmeans <- list(
  p1 = length(grupo1) / length(dados_petroleo),
  gamma1 = 0,
  mu1 = mean(grupo1),
  sigma1 = max(sd(grupo1), 0.1), # Evitar sd = 0
  gamma2 = 0,
  mu2 = mean(grupo2),
  sigma2 = max(sd(grupo2), 0.1) # Evitar sd = 0
)

# Rodar o algoritmo EM
# Usamos 'verbose = FALSE' para uma saÃ­da limpa, jÃ¡ que o objetivo Ã© sÃ³ o grÃ¡fico
resultado_em_real <- em_gev_mixture(
  x = dados_petroleo,
  initial_params = params_iniciais_kmeans,
  max_iter = 200, # Aumentar para garantir convergÃªncia
  tol = 1e-6,     # Aumentar precisÃ£o
  verbose = FALSE
)

# Extrair as estimativas finais dos parÃ¢metros
estimativas_finais <- resultado_em_real$estimates


# --- PASSO 3: Gerar o grÃ¡fico final para o relatÃ³rio ---

# Criar o grÃ¡fico com ggplot2
grafico_final_aplicacao <- ggplot(data.frame(x = dados_petroleo), aes(x = x)) +
  # Camada do histograma dos dados
  geom_histogram(aes(y = ..density..), bins = 15, fill = "lightgray", 
                 color = "black", alpha = 0.8) +
  
  # Camada da curva da densidade da mistura ajustada
  stat_function(
    fun = dmixture_gev,
    args = list(
      p1 = estimativas_finais$p1,
      gamma1 = estimativas_finais$gamma1, mu1 = estimativas_finais$mu1, sigma1 = estimativas_finais$sigma1,
      gamma2 = estimativas_finais$gamma2, mu2 = estimativas_finais$mu2, sigma2 = estimativas_finais$sigma2
    ),
    color = "red", size = 1.1
  ) +
  
  # RÃ³tulos e tema do grÃ¡fico
  labs(
    title = "Ajuste do Modelo de Mistura GEV ao Dados de PetrÃ³leo",
    subtitle = sprintf("Ajuste via Algoritmo EM | Log-VerossimilhanÃ§a Final: %.2f", resultado_em_real$log_likelihood),
    x = "Log(Consumo de PetrÃ³leo per capita)",
    y = "Densidade"
  ) +
  theme_minimal(base_size = 14)

# Exibir o grÃ¡fico
print(grafico_final_aplicacao)
```

